Timer unit: 1e-06 s

Total time: 97.4725 s
File: /gpfs/bbp.cscs.ch/home/leite/dev/neurodamus/python/neurodamus/cell_distributor.py
Function: _setup at line 66

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    66                                               def _setup(self, run_conf, targets_conf):
    67         1         16.0     16.0      0.0          morpho_path = run_conf.get("MorphologyPath").s
    68                                           
    69                                                   # for testing if xopen bcast is in use (NEURON 7.3).
    70                                                   # We will be loading different templates on different cpus, so it must be disabled for now
    71         1         21.0     21.0      0.0          Nd.execute("xopen_broadcast_ = 0")
    72                                           
    73                                                   # determine if we should get metype info from start.ncs (current default) or circuit.mvd3
    74         1         10.0     10.0      0.0          if run_conf.exists("CellLibraryFile"):
    75         1          5.0      5.0      0.0              celldb_filename = run_conf.get("CellLibraryFile").s
    76         1          2.0      2.0      0.0              if celldb_filename == "circuit.mvd3":
    77         1        178.0    178.0      0.0                  logging.info("Reading gid:METype info from circuit.mvd3")
    78         1          1.0      1.0      0.0                  self._useMVD3 = True
    79                                           
    80                                                       elif celldb_filename != "start.ncs":
    81                                                           logging.error("Invalid CellLibraryFile %s. Terminating", celldb_filename)
    82                                                           raise ConfigurationError("Invalid CellLibFile".format(celldb_filename))
    83                                                   # Default
    84         1          1.0      1.0      0.0          if not self._useMVD3:
    85                                                       logging.info("Reading gid:METype info from start.ncs")
    86                                           
    87         1          1.0      1.0      0.0          gidvec = None       # Gids handled by this cpu
    88         1          1.0      1.0      0.0          total_cells = None  # total cells in this simulation (can be a subset, e.g.: target)
    89                                           
    90                                                   #  are we using load balancing? If yes, init structs accordingly
    91         1         14.0     14.0      0.0          if run_conf.exists("RunMode") \
    92         1          5.0      5.0      0.0                  and run_conf.get("RunMode").s in ("LoadBalance", "WholeCell"):
    93         1         94.0     94.0      0.0              logging.info("  > Distributing cells according to load-balance")
    94         1          2.0      2.0      0.0              self._lb_flag = True
    95         1         16.0     16.0      0.0              self._spgidvec = compat.Vector("I")
    96         1          2.0      2.0      0.0              gidvec = compat.Vector("I")
    97                                           
    98                                                       # read the cx_* files to build the gidvec
    99         1          7.0      7.0      0.0              cx_path = "cx_%d" % MPI.cpu_count
   100         1         11.0     11.0      0.0              if run_conf.exists("CWD"):
   101                                                           # Should we allow for another path to facilitate reusing cx* files?
   102                                                           cx_path = path.join(run_conf.get("CWD").s, cx_path)
   103                                           
   104                                                       # self.binfo reads the files that have the predistributed cells (and pieces)
   105         1       7949.0   7949.0      0.0              self._binfo = Nd.BalanceInfo(cx_path, MPI.rank, MPI.cpu_count)
   106                                           
   107                                                       # self.binfo has gidlist, but gids can appear multiple times
   108         1          3.0      3.0      0.0              _seen = set()
   109       126        155.0      1.2      0.0              for gid in self._binfo.gids:
   110       125        176.0      1.4      0.0                  gid = int(gid)
   111       125        156.0      1.2      0.0                  if gid not in _seen:
   112       125        184.0      1.5      0.0                      gidvec.append(gid)
   113       125        171.0      1.4      0.0                      _seen.add(gid)
   114                                           
   115                                                       # TODO: do we have any way of knowing that a CircuitTarget found definitively matches
   116                                                       #       the cells in the balance files? for now, assume the user is being honest
   117         1         14.0     14.0      0.0              if run_conf.exists("CircuitTarget"):
   118         1         17.0     17.0      0.0                  target = targets_conf.getTarget(run_conf.get("CircuitTarget").s)
   119         1         10.0     10.0      0.0                  total_cells = int(target.completegids().size())
   120                                                       else:
   121                                                           total_cells = len(_seen)
   122                                           
   123                                                   elif run_conf.exists("CircuitTarget"):
   124                                                       logging.info("  > Distributing target circuit cells round-robin")
   125                                                       target = targets_conf.getTarget(run_conf.get("CircuitTarget").s)
   126                                                       gidvec = compat.Vector("I")
   127                                                       _target_gids = target.completegids()
   128                                                       total_cells = int(_target_gids.size())
   129                                           
   130                                                       for i, gid in enumerate(_target_gids):
   131                                                           if i % MPI.cpu_count == MPI.rank:
   132                                                               gidvec.append(int(gid))
   133                                                   else:
   134                                                       # Otherwise distribute all the cells round robin style. readNCS / readMVD3 handle this
   135                                                       logging.info("  > Distributing all cells round-robin")
   136                                           
   137                                                   # Determine metype; apply round-robin assignment if necessary
   138         1          1.0      1.0      0.0          if self._useMVD3:
   139         1          2.0      2.0      0.0              self._total_cells, self._gidvec, me_infos = self._load_mvd3(
   140         1    2537769.0 2537769.0      2.6                  run_conf, total_cells, gidvec)
   141                                                   else:
   142                                                       self._total_cells, self._gidvec, me_infos = self._load_ncs(
   143                                                           run_conf, total_cells, gidvec)
   144                                           
   145         1          4.0      4.0      0.0          logging.info("Done gid assignment: %d cells in network, %d cells in rank 0",
   146         1        288.0    288.0      0.0                       self._total_cells, len(self._gidvec))
   147                                           
   148         1          7.0      7.0      0.0          self._pnm.ncell = self._total_cells
   149         1         17.0     17.0      0.0          mepath = run_conf.get("METypePath").s
   150         1        101.0    101.0      0.0          logging.info("Loading cells...")
   151                                           
   152       126       8315.0     66.0      0.0          for gid in ProgressBar.iter(self._gidvec):
   153       125        238.0      1.9      0.0              if self._useMVD3:
   154       125        677.0      5.4      0.0                  meinfo_v6 = me_infos.retrieve_info(gid)
   155       125        264.0      2.1      0.0                  melabel = meinfo_v6.emodel
   156       125   94912653.0 759301.2     97.4                  cell = METype(gid, mepath, melabel, morpho_path, meinfo_v6)
   157                                                       else:
   158                                                           # In NCS, me_infos is a plain map from gid to me_file
   159                                                           melabel = self._load_template(me_infos[gid], mepath)
   160                                                           cell = METype(gid, mepath, melabel, morpho_path)
   161                                           
   162       125        695.0      5.6      0.0              self._gid2metype[gid] = melabel
   163       125        384.0      3.1      0.0              self._cell_list.append(cell)
   164       125        289.0      2.3      0.0              self._gid2meobj[gid] = cell
   165       125       1571.0     12.6      0.0              self._pnm.cells.append(cell.CellRef)

Total time: 0.246918 s
File: /gpfs/bbp.cscs.ch/home/leite/dev/neurodamus/python/neurodamus/cell_distributor.py
Function: finalize at line 496

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   496                                               def finalize(self, gids):
   497                                                   """Do final steps to setup the network. For example, multisplit will handle gids depending
   498                                                   on additional info from self.binfo object. Otherwise, normal cells do their finalization
   499                                           
   500                                                   Args:
   501                                                       gids: The gids of the cells to finalize
   502                                           
   503                                                   """
   504                                                   # First, we need each section of a cell to assign its index value to the voltage field
   505                                                   # (crazy, huh?) at this moment, this is used later during synapse creation so that sections
   506                                                   # can be serialized into a single array for random acess.
   507         1         14.0     14.0      0.0          rng_info = Nd.RNGSettings()
   508         1          5.0      5.0      0.0          self._global_seed = rng_info.getGlobalSeed()
   509         1          4.0      4.0      0.0          self._ionchannel_seed = rng_info.getIonChannelSeed()
   510                                           
   511       126        174.0      1.4      0.1          for i, gid in enumerate(gids):
   512       125        155.0      1.2      0.1              metype = self._cell_list[i]  # type: METype
   513                                           
   514                                                       #  for v6 and beyond - we can just try to invoke rng initialization
   515       125        135.0      1.1      0.1              if self._useMVD3 or rng_info.getRNGMode() == rng_info.COMPATIBILITY:
   516       125      36184.0    289.5     14.7                  metype.re_init_rng(self._ionchannel_seed)
   517                                                       else:
   518                                                           # for v5 circuits and earlier check if cell has re_init function.
   519                                                           # Instantiate random123 or mcellran4 as appropriate
   520                                                           # Note: should CellDist be aware that metype has CCell member?
   521                                                           ret = hasattr(metype.CCell, "re_init_rng")
   522                                           
   523                                                           if ret:
   524                                                               if rng_info.getRNGMode() == rng_info.RANDOM123:
   525                                                                   Nd.rng123ForStochKvInit(metype.CCell)
   526                                                               else:
   527                                                                   if metype.gid > 400000:
   528                                                                       logging.warning("mcellran4 cannot initialize properly with large gids")
   529                                                                   Nd.rngForStochKvInit(metype.CCell)
   530                                           
   531                                                       # TODO: CCell backwards compatibility
   532                                                       # if we drop support for older versions use simply cell.CCellRef.connect2target(nil, nc)
   533       125        226.0      1.8      0.1              version = metype.getVersion()
   534       125        144.0      1.2      0.1              if version < 2:
   535                                                           nc = Nd.nc_
   536                                                           metype.CellRef.connect2target(Nd.nil, nc)
   537                                                       else:
   538       125       2951.0     23.6      1.2                  nc = metype.connect2target(Nd.nil)
   539                                           
   540       125        160.0      1.3      0.1              if self._lb_flag:
   541       125        532.0      4.3      0.2                  ic = int(self._binfo.gids.indwhere("==", gid))
   542       125        528.0      4.2      0.2                  cb = self._binfo.bilist.object(self._binfo.cbindex.x[ic])
   543                                           
   544       125        385.0      3.1      0.2                  if cb.subtrees.count() == 0:
   545                                                               #  whole cell, normal creation
   546       125       1312.0     10.5      0.5                      self._pnm.set_gid2node(gid, MPI.rank)
   547       125        407.0      3.3      0.2                      self._pnm.pc.cell(gid, nc)
   548       125        201.0      1.6      0.1                      self._spgidvec.append(gid)
   549                                                           else:
   550                                                               spgid = cb.multisplit(nc, self._binfo.msgid, self._pnm.pc, MPI.rank)
   551                                                               self._spgidvec.append(spgid)
   552                                           
   553                                                       else:
   554                                                           self._pnm.set_gid2node(gid, self._pnm.myid)
   555                                                           self._pnm.pc.cell(gid, nc)
   556                                           
   557                                                   # TODO: on bbplinsrv, calling pc.multisplit function now causes problem, but if it is called
   558                                                   #  in a separate function after return, then it is fine. Maybe contact Michael for advice?
   559         1          1.0      1.0      0.0          if self._lb_flag:
   560         1     203400.0 203400.0     82.4              self._pnm.pc.multisplit()

Total time: 106.65 s
File: /gpfs/bbp.cscs.ch/home/leite/dev/neurodamus/python/neurodamus/connection.py
Function: finalize at line 182

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   182                                               def finalize(self, pnm, cell, base_seed=None, tgid_override=None):
   183                                                   """ When all parameters are set, create synapses and netcons
   184                                           
   185                                                   Args:
   186                                                       pnm: parallelNetManager object which manages cells (& netcons) for NEURON
   187                                                       cell: cell provided directly rather than via pnm to avoid loadbalance issues
   188                                                       base_seed: base seed value (leave default None in case no adjustment is needed)
   189                                                       tgid_override: optional argument which overrides the tgid in the event of loadbalancing
   190                                           
   191                                                   """
   192     76506     142967.0      1.9      0.1          tgid = tgid_override if tgid_override is not None else self.tgid
   193     76506     124092.0      1.6      0.1          weight_adjusts = []
   194     76506     115282.0      1.5      0.1          wa_netcon_pre = []
   195     76506     114477.0      1.5      0.1          wa_netcon_post = []
   196     76506     459966.0      6.0      0.4          rng_info = ND.RNGSettings()
   197     76506     376836.0      4.9      0.4          tbins_vec = ND.Vector(1)
   198     76506     211986.0      2.8      0.2          tbins_vec.x[0] = 0.0
   199     76506     349571.0      4.6      0.3          rate_vec = ND.Vector(1)
   200                                           
   201                                                   # Initialize member lists
   202     76506     175130.0      2.3      0.2          self._synapses = compat.List()
   203     76506     142010.0      1.9      0.1          self._netcons = []
   204     76506     132264.0      1.7      0.1          self._minis_netcons = []
   205     76506     128981.0      1.7      0.1          self._minis_RNGs = []
   206                                           
   207                                                   # Note that synapseLocation.SPLIT = 1
   208                                                   # All locations, on and off node should be in this list, but only synapses/netcons on-node
   209                                                   # should get instantiated
   210    397260    1102095.0      2.8      1.0          for syn_i, sc in enumerate(self._tpoint_man.sclst):
   211    320754     900915.0      2.8      0.8              if not sc.exists():
   212                                                           continue
   213                                                       # Put the section in the stack, so generic hoc instructions apply to the right section
   214    320754     943569.0      2.9      0.9              sc.sec.push()
   215                                           
   216    320754     808265.0      2.5      0.8              x = self._tpoint_man.x[syn_i]
   217    320754     560123.0      1.7      0.5              syn_params = self._synapse_params[syn_i]
   218    320754   43786112.0    136.5     41.1              syn_obj = self._create_synapse(cell, syn_params, x, self._synapse_ids[syn_i], base_seed)
   219    320754     974481.0      3.0      0.9              cell_syn_list = cell.CellRef.synlist
   220    320754     626319.0      2.0      0.6              self._synapses.append(syn_obj)
   221                                           
   222                                                       # see also pc.gid_connect
   223                                                       # if sgid exists (i.e. both gids are local), makes netcon connection (c/c++) immediately
   224                                                       # if sgid not exist, creates an input PreSyn to receive spikes transited over the net.
   225                                                       # PreSyn is the source to the NetCon, cannot ask netcon about the preloc, but srcgid ok
   226                                           
   227    320754    1037915.0      3.2      1.0              nc_index = pnm.nc_append(self.sgid, tgid, cell_syn_list.count()-1,
   228    320754   11202610.0     34.9     10.5                                       syn_params.delay, syn_params.weight)
   229    320754    1222886.0      3.8      1.1              nc = pnm.nclist.object(nc_index)  # Netcon object
   230    320754    5301638.0     16.5      5.0              nc.delay = syn_params.delay
   231    320754    5356575.0     16.7      5.0              nc.weight[0] = syn_params.weight * self.weight_factor
   232    320754     812538.0      2.5      0.8              nc.threshold = -30
   233                                           
   234                                                       # If the config has UseSTDP, do STDP stuff (can add more options later
   235                                                       #   here and in Connection.init). Instantiates the appropriate StdpWA mod file
   236    320754     563575.0      1.8      0.5              if self._stdp:
   237                                                           if self._stdp == STDPMode.DOUBLET_STDP:
   238                                                               weight_adjuster = ND.StdpWADoublet(x)
   239                                                           elif self._stdp == STDPMode.TRIPLET_STDP:
   240                                                               weight_adjuster = ND.StdpWATriplet(x)
   241                                                           else:
   242                                                               raise ValueError("Invalid STDP config")
   243                                           
   244                                                           # The synapse ID is useful for synapse reporting
   245                                                           weight_adjuster.synapseID = syn_obj.synapseID
   246                                           
   247                                                           # Create netcons for the pre and post synaptic cells
   248                                                           #   with weights of 1 and -1, respectively
   249                                                           nc_wa_pre = pnm.pc.gid_connect(self.sgid, weight_adjuster)
   250                                                           nc_wa_pre.threshold = -30
   251                                                           nc_wa_pre.weight[0] = 1
   252                                                           nc_wa_pre.delay = syn_params.delay
   253                                           
   254                                                           nc_wa_post = pnm.pc.gid_connect(tgid, weight_adjuster)
   255                                                           nc_wa_post.threshold = -30
   256                                                           nc_wa_post.weight[0] = -1
   257                                                           nc_wa_post.delay = syn_params.delay
   258                                           
   259                                                           # Set the pointer to the synapse netcon weight
   260                                                           ND.setpointer(nc._ref_weight, "wsyn", weight_adjuster)
   261                                           
   262                                                           weight_adjusts.append(weight_adjuster)
   263                                                           wa_netcon_pre.append(nc_wa_pre)
   264                                                           wa_netcon_post.append(nc_wa_post)
   265                                           
   266    320754     573922.0      1.8      0.5              if self._minis_spont_rate > 0.0:
   267    320754    1792776.0      5.6      1.7                  ips = ND.InhPoissonStim(x)
   268                                                           # netconMini = pnm.pc.gid_connect(ips, finalgid)
   269                                           
   270                                                           # A simple NetCon will do, as the synapse and cell are local.
   271    320754    2207448.0      6.9      2.1                  netcon_m = ND.NetCon(ips, syn_obj)
   272    320754     809259.0      2.5      0.8                  netcon_m.delay = 0.1
   273                                                           # TODO: better solution here to get the desired behaviour during
   274                                                           # delayed connection blocks
   275                                                           # Right now spontaneous minis should be unaffected by delays
   276    320754    5518422.0     17.2      5.2                  netcon_m.weight[0] = syn_params.weight * self.weight_factor
   277    320754     656920.0      2.0      0.6                  self._minis_netcons.append(netcon_m)
   278    320754    1247877.0      3.9      1.2                  if rng_info.getRNGMode() == rng_info.RANDOM123:
   279    320754    1307977.0      4.1      1.2                      ips.setRNGs(syn_obj.synapseID+200, tgid+250, rng_info.getMinisSeed()+300,
   280    320754    1570593.0      4.9      1.5                                  syn_obj.synapseID+200, tgid+250, rng_info.getMinisSeed()+350)
   281                                                           else:
   282                                                               exprng = ND.Random()
   283                                                               if rng_info.getRNGMode() == rng_info.COMPATIBILITY:
   284                                                                   exprng.MCellRan4(syn_obj.synapseID*100000 + 200,
   285                                                                                    tgid + 250 + base_seed + rng_info.getMinisSeed())
   286                                                               else:  # if ( rngIndo.getRNGMode()== rng_info.UPMCELLRAN4 ):
   287                                                                   exprng.MCellRan4(syn_obj.synapseID*1000 + 200,
   288                                                                                    tgid + 250 + base_seed + rng_info.getMinisSeed())
   289                                           
   290                                                               exprng.negexp(1)
   291                                                               uniformrng = ND.Random()
   292                                                               if rng_info.getRNGMode() == rng_info.COMPATIBILITY:
   293                                                                   uniformrng.MCellRan4(syn_obj.synapseID*100000 + 300,
   294                                                                                        tgid + 250 + base_seed + rng_info.getMinisSeed())
   295                                                               else:  # if ( rngIndo.getRNGMode()== rng_info.UPMCELLRAN4 ):
   296                                                                   uniformrng.MCellRan4(syn_obj.synapseID*1000 + 300,
   297                                                                                        tgid + 250 + base_seed + rng_info.getMinisSeed())
   298                                           
   299                                                               uniformrng.uniform(0.0, 1.0)
   300                                                               ips.setRNGs(exprng, uniformrng)
   301                                           
   302                                                               # keep variables so they don't get deleted
   303                                                               self._minis_RNGs.append(exprng)
   304                                                               self._minis_RNGs.append(uniformrng)
   305                                           
   306                                                           # we never use this list, so I can put the ips in here too
   307    320754     626704.0      2.0      0.6                  self._minis_RNGs.append(ips)
   308    320754     618720.0      1.9      0.6                  self._minis_RNGs.append(tbins_vec)
   309    320754     595009.0      1.9      0.6                  self._minis_RNGs.append(rate_vec)
   310                                           
   311                                                           # set the rate of the ips
   312    320754     810209.0      2.5      0.8                  rate_vec.x[0] = self._minis_spont_rate
   313    320754     994682.0      3.1      0.9                  ips.setTbins(tbins_vec)
   314    320754     937709.0      2.9      0.9                  ips.setRate(rate_vec)
   315                                           
   316    320754     638504.0      2.0      0.6              self._netcons.append(nc)
   317    320754    1500766.0      4.7      1.4              ND.pop_section()  # clear selection
   318                                           
   319                                                   # Apply configurations to the synapses
   320     76506    6569450.0     85.9      6.2          self._configure_synapses()

Total time: 40.7256 s
File: /gpfs/bbp.cscs.ch/home/leite/dev/neurodamus/python/neurodamus/connection.py
Function: _create_synapse at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               def _create_synapse(self, cell, params_obj, x, syn_id, base_seed):
   324                                                   """Create synapse (GABBAB inhibitory, AMPANMDA excitatory, or another type defined by
   325                                                   self._synapse_override) passing the creation helper the params.
   326                                                   It also appends the synapse to the corresponding cell lists.
   327                                           
   328                                                   Args:
   329                                                       cell: The cell object
   330                                                       params_obj: SynapseParameters object for the synapse to be placed at a single location
   331                                                       x: distance into the currently accessed section (cas)
   332                                                       syn_id: Synapse id (determined by row number in the nrn.h5 dataset)
   333                                                       base_seed: base seed to adjust synapse RNG - added to MCellRan4's low index parameter
   334                                           
   335                                                   """
   336    320754     310461.0      1.0      0.8          if self._synapse_override is not None:
   337                                                       # there should be a 'Helper' for that syntype in the hoc path.
   338                                                       override_helper = self._synapse_override.get("ModOverride") + "Helper"
   339                                                       ND.load_hoc(override_helper)
   340                                                       try:
   341                                                           helper_cls = getattr(ND.h, override_helper)
   342                                                       except AttributeError:
   343                                                           raise RuntimeError("Failed to load override helper " + override_helper)
   344                                                   else:
   345    320754    5726892.0     17.9     14.1              helper_cls = ND.GABAABHelper if params_obj.synType < 100 \
   346    266202     769966.0      2.9      1.9                  else ND.AMPANMDAHelper  # excitatory
   347                                           
   348    320754   31000814.0     96.6     76.1          syn_helper = helper_cls(self.tgid, params_obj, x, syn_id, base_seed, self._synapse_override)
   349    320754    1366293.0      4.3      3.4          cell.CellRef.synHelperList.append(syn_helper)
   350    320754    1149075.0      3.6      2.8          cell.CellRef.synlist.append(syn_helper.synapse)
   351    320754     402126.0      1.3      1.0          return syn_helper.synapse

Total time: 5.97138 s
File: /gpfs/bbp.cscs.ch/home/leite/dev/neurodamus/python/neurodamus/connection.py
Function: apply_configuration at line 434

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   434                                               def apply_configuration(self, configuration):
   435                                                   """ Helper function to execute a configuration command on all connection synapses.
   436                                                   """
   437                                                   # NOTE: After the simulation has run for some time we can't assume that the last synapse
   438                                                   # of the cell object is the target
   439                                                   # self._apply_configuration(configuration, tuple(self._synapses))
   440    159551    5971380.0     37.4    100.0          self.ConnUtils.executeConfigure(self._synapses, configuration)

Total time: 212.15 s
File: /gpfs/bbp.cscs.ch/home/leite/dev/neurodamus/python/neurodamus/connection_manager.py
Function: group_connect at line 107

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   107                                               def group_connect(self, src_target, dst_target, gidvec, weight_factor=None, configuration=None,
   108                                                                 stdp_mode=None, spont_mini_rate=0, synapse_types=None, synapse_override=None):
   109                                                   """Given source and destination targets, create all connections for post-gids in gidvec.
   110                                                   Note: the cells in the source list are not limited by what is on this cpu whereas
   111                                                   the dest list requires the cells be local
   112                                           
   113                                                   Args:
   114                                                       src_target: Name of Source Target
   115                                                       dst_target: Name of Destination Target
   116                                                       gidvec: Vector of gids on the local cpu
   117                                                       weight_factor: (float) Scaling weight to apply to the synapses. Default: dont change
   118                                                       configuration: (str) SynapseConfiguration Default: None
   119                                                       stdp_mode: Which STDP to use. Default: None (=TDPoff for creating, wont change existing)
   120                                                       spont_mini_rate: (float) For spontaneous minis trigger rate (default: 0)
   121                                                       synapse_types: (tuple) To restrict which synapse types are created. Default: None
   122                                                       synapse_override: An alternative point process configuration.
   123                                                   """
   124                                                   # unlike connectAll, we must look through self._connections_map to see if sgid->tgid exists
   125                                                   # because it may be getting weights updated.
   126                                                   # Note: it is better to get the whole target over just the gid vector since then we can use
   127                                                   # utility functions like 'contains'
   128        23        425.0     18.5      0.0          src_target = self._target_manager.getTarget(src_target)
   129        23        416.0     18.1      0.0          dst_target = self._target_manager.getTarget(dst_target)
   130        23        115.0      5.0      0.0          stdp = STDPMode.from_str(stdp_mode) if stdp_mode is not None else None
   131        23         25.0      1.1      0.0          synapses_restrict = synapse_types is not None
   132        23         23.0      1.0      0.0          if synapses_restrict and not isinstance(synapse_types, (tuple, list)):
   133                                                       synapse_types = (synapse_types,)
   134                                           
   135      2898       3862.0      1.3      0.0          for tgid in gidvec:
   136      2875      21649.0      7.5      0.0              if not dst_target.contains(tgid):  # if tgid not in dst_target:
   137      1619       1710.0      1.1      0.0                  continue
   138                                           
   139                                                       # this cpu owns some or all of the destination gid
   140      1256   33363532.0  26563.3     15.7              syns_params = self.get_synapse_parameters(tgid)
   141      1256       1427.0      1.1      0.0              prev_sgid = None
   142      1256       1291.0      1.0      0.0              pend_conn = None
   143                                           
   144   3303607   23123306.0      7.0     10.9              for i, syn_params in enumerate(syns_params):
   145   3302351    3661596.0      1.1      1.7                  if synapses_restrict and syn_params.synType not in synapse_types:
   146                                                               continue
   147                                           
   148                                                           # if this gid in the source target?
   149   3302351   54625841.0     16.5     25.7                  sgid = int(syn_params.sgid)
   150   3302351   45034006.0     13.6     21.2                  if not src_target.completeContains(sgid):
   151   2302548    2548305.0      1.1      1.2                      continue
   152                                           
   153                                                           # is this gid in the self._circuit_target (if defined)
   154    999803    1257881.0      1.3      0.6                  if self._circuit_target and not self._circuit_target.completeContains(sgid):
   155                                                               continue
   156                                           
   157                                                           # are we on a different sgid than the previous iteration?
   158    999803    1135741.0      1.1      0.5                  if sgid != prev_sgid:
   159                                                               # if we were putting things in a pending object, we can store that away now
   160    236057     249171.0      1.1      0.1                      if pend_conn:
   161     76256    2104751.0     27.6      1.0                          self.store_connection(pend_conn)
   162     76256      89282.0      1.2      0.0                          pend_conn = None
   163    236057     245532.0      1.0      0.1                      prev_sgid = sgid
   164                                           
   165                                                               # determine what we will do with the new sgid
   166                                                               # update params if seen before, or create connection
   167    236057    6522559.0     27.6      3.1                      cur_conn = self.get_connection(sgid, tgid)  # type: Connection
   168    236057     285311.0      1.2      0.1                      if cur_conn is not None:
   169    159551     175037.0      1.1      0.1                          if weight_factor is not None:
   170    159551     208739.0      1.3      0.1                              cur_conn.weight_factor = weight_factor
   171    159551     176491.0      1.1      0.1                          if configuration is not None:
   172    159551     480079.0      3.0      0.2                              cur_conn.add_synapse_configuration(configuration)
   173    159551     178114.0      1.1      0.1                          if stdp is not None:
   174    159551     688582.0      4.3      0.3                              cur_conn.stdp = stdp
   175    159551     185401.0      1.2      0.1                          if synapse_override is not None:
   176                                                                       cur_conn.override_synapse(synapse_override)
   177    159551     175206.0      1.1      0.1                          pend_conn = None
   178                                                               else:
   179     76506      88937.0      1.2      0.0                          if self._creation_mode:
   180     76506      83753.0      1.1      0.0                              if weight_factor is None:
   181                                                                           logging.warning("Invalid weight_factor for connection creation. "
   182                                                                                           "Assuming 1.0")
   183     76506      89232.0      1.2      0.0                              pend_conn = Connection(sgid, tgid, weight_factor, configuration, stdp,
   184     76506      90299.0      1.2      0.0                                                     spont_mini_rate, self._synapse_mode,
   185     76506    2509331.0     32.8      1.2                                                     synapse_override)
   186                                           
   187                                                           # if we have a pending connection we place the current synapse(s)
   188    999803    1092653.0      1.1      0.5                  if pend_conn is not None:
   189    320754    5672074.0     17.7      2.7                      point = self._target_manager.locationToPoint(tgid, syn_params.isec,
   190    320754   17377274.0     54.2      8.2                                                                   syn_params.ipt, syn_params.offset)
   191    320754    8591165.0     26.8      4.0                      pend_conn.add_synapse(point, syn_params, i)
   192                                           
   193                                                       # store any remaining pending connection
   194      1256       1496.0      1.2      0.0              if pend_conn is not None:
   195       250       7940.0     31.8      0.0                  self.store_connection(pend_conn)

Total time: 27.9905 s
File: /gpfs/bbp.cscs.ch/home/leite/dev/neurodamus/python/neurodamus/connection_manager.py
Function: get_synapse_parameters at line 198

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   198                                               def get_synapse_parameters(self, gid):
   199                                                   """Access the specified dataset from the nrn.h5 file to get all synapse parameters for
   200                                                   a post-synaptic cell
   201                                           
   202                                                   Args:
   203                                                       gid: The gid of the cell whose parameters are required
   204                                           
   205                                                   Returns: A list containing the parameters (SynapseParameters objects) of each synapse
   206                                                   """
   207      1256       2332.0      1.9      0.0          if gid in self._syn_params:
   208      1131       1584.0      1.4      0.0              return self._syn_params[gid]  # Cached
   209                                           
   210       125        425.0      3.4      0.0          cell_name = "a%d" % gid
   211       125        158.0      1.3      0.0          if self._n_synapse_files > 1:
   212                                                       ret = self._synapse_reader.loadData(gid)
   213                                                   else:
   214       125    9384431.0  75075.4     33.5              ret = self._synapse_reader.loadData(cell_name)
   215                                           
   216       125        360.0      2.9      0.0          if ret < 0:
   217                                                       logging.warning("No synapses for %s. Skipping", cell_name)
   218                                                       return []
   219                                           
   220       125       1298.0     10.4      0.0          dt = ND.dt
   221       125        184.0      1.5      0.0          reader = self._synapse_reader
   222       125        968.0      7.7      0.0          nrow = int(reader.numberofrows(cell_name))
   223       125      21947.0    175.6      0.1          conn_syn_params = SynapseParameters.create_array(nrow)
   224       125        275.0      2.2      0.0          self._syn_params[gid] = conn_syn_params
   225                                           
   226    320879     334621.0      1.0      1.2          for i in range(nrow):
   227    320754    2107697.0      6.6      7.5              params = conn_syn_params[i]
   228    320754    1256643.0      3.9      4.5              params[0] = reader.getData(cell_name, i, 0)   # sgid
   229    320754    1114885.0      3.5      4.0              params[1] = reader.getData(cell_name, i, 1)   # delay
   230    320754    1108645.0      3.5      4.0              params[2] = reader.getData(cell_name, i, 2)   # isec
   231    320754    1101807.0      3.4      3.9              params[3] = reader.getData(cell_name, i, 3)   # ipt
   232    320754    1100938.0      3.4      3.9              params[4] = reader.getData(cell_name, i, 4)   # offset
   233    320754    1100258.0      3.4      3.9              params[5] = reader.getData(cell_name, i, 8)   # weight
   234    320754    1100475.0      3.4      3.9              params[6] = reader.getData(cell_name, i, 9)   # U
   235    320754    1101398.0      3.4      3.9              params[7] = reader.getData(cell_name, i, 10)  # D
   236    320754    1100627.0      3.4      3.9              params[8] = reader.getData(cell_name, i, 11)  # F
   237    320754    1098730.0      3.4      3.9              params[9] = reader.getData(cell_name, i, 12)  # DTC
   238    320754    1099463.0      3.4      3.9              params[10] = reader.getData(cell_name, i, 13)  # isynType
   239    320754     389729.0      1.2      1.4              if self._nrn_version > 4:
   240    320754    1127593.0      3.5      4.0                  params[11] = reader.getData(cell_name, i, 17)  # nrrp
   241                                                       else:
   242                                                           params[11] = -1
   243                                                       # compensate for minor floating point inaccuracies in the delay
   244    320754    2332942.0      7.3      8.3              params[1] = int(params[1] / dt + 1e-5) * dt
   245                                           
   246       125        121.0      1.0      0.0          return conn_syn_params

